/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `WplMatchInfo` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/client';
import type * as $Enums from '../enums';
import type * as Prisma from '../internal/prismaNamespace';

/**
 * Model WplMatchInfo
 *
 */
export type WplMatchInfoModel = runtime.Types.Result.DefaultSelection<Prisma.$WplMatchInfoPayload>;

export type AggregateWplMatchInfo = {
  _count: WplMatchInfoCountAggregateOutputType | null;
  _avg: WplMatchInfoAvgAggregateOutputType | null;
  _sum: WplMatchInfoSumAggregateOutputType | null;
  _min: WplMatchInfoMinAggregateOutputType | null;
  _max: WplMatchInfoMaxAggregateOutputType | null;
};

export type WplMatchInfoAvgAggregateOutputType = {
  id: number | null;
  ballsPerOver: number | null;
  matchNumber: number | null;
  winnerRuns: number | null;
  winnerWickets: number | null;
};

export type WplMatchInfoSumAggregateOutputType = {
  id: number | null;
  ballsPerOver: number | null;
  matchNumber: number | null;
  winnerRuns: number | null;
  winnerWickets: number | null;
};

export type WplMatchInfoMinAggregateOutputType = {
  id: number | null;
  league: string | null;
  version: string | null;
  ballsPerOver: number | null;
  gender: string | null;
  season: string | null;
  date: Date | null;
  event: string | null;
  matchNumber: number | null;
  venue: string | null;
  city: string | null;
  tossWinner: string | null;
  tossDecision: string | null;
  playerOfMatch: string | null;
  winner: string | null;
  winnerRuns: number | null;
  winnerWickets: number | null;
};

export type WplMatchInfoMaxAggregateOutputType = {
  id: number | null;
  league: string | null;
  version: string | null;
  ballsPerOver: number | null;
  gender: string | null;
  season: string | null;
  date: Date | null;
  event: string | null;
  matchNumber: number | null;
  venue: string | null;
  city: string | null;
  tossWinner: string | null;
  tossDecision: string | null;
  playerOfMatch: string | null;
  winner: string | null;
  winnerRuns: number | null;
  winnerWickets: number | null;
};

export type WplMatchInfoCountAggregateOutputType = {
  id: number;
  league: number;
  version: number;
  ballsPerOver: number;
  gender: number;
  season: number;
  date: number;
  event: number;
  matchNumber: number;
  venue: number;
  city: number;
  tossWinner: number;
  tossDecision: number;
  playerOfMatch: number;
  winner: number;
  winnerRuns: number;
  winnerWickets: number;
  _all: number;
};

export type WplMatchInfoAvgAggregateInputType = {
  id?: true;
  ballsPerOver?: true;
  matchNumber?: true;
  winnerRuns?: true;
  winnerWickets?: true;
};

export type WplMatchInfoSumAggregateInputType = {
  id?: true;
  ballsPerOver?: true;
  matchNumber?: true;
  winnerRuns?: true;
  winnerWickets?: true;
};

export type WplMatchInfoMinAggregateInputType = {
  id?: true;
  league?: true;
  version?: true;
  ballsPerOver?: true;
  gender?: true;
  season?: true;
  date?: true;
  event?: true;
  matchNumber?: true;
  venue?: true;
  city?: true;
  tossWinner?: true;
  tossDecision?: true;
  playerOfMatch?: true;
  winner?: true;
  winnerRuns?: true;
  winnerWickets?: true;
};

export type WplMatchInfoMaxAggregateInputType = {
  id?: true;
  league?: true;
  version?: true;
  ballsPerOver?: true;
  gender?: true;
  season?: true;
  date?: true;
  event?: true;
  matchNumber?: true;
  venue?: true;
  city?: true;
  tossWinner?: true;
  tossDecision?: true;
  playerOfMatch?: true;
  winner?: true;
  winnerRuns?: true;
  winnerWickets?: true;
};

export type WplMatchInfoCountAggregateInputType = {
  id?: true;
  league?: true;
  version?: true;
  ballsPerOver?: true;
  gender?: true;
  season?: true;
  date?: true;
  event?: true;
  matchNumber?: true;
  venue?: true;
  city?: true;
  tossWinner?: true;
  tossDecision?: true;
  playerOfMatch?: true;
  winner?: true;
  winnerRuns?: true;
  winnerWickets?: true;
  _all?: true;
};

export type WplMatchInfoAggregateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which WplMatchInfo to aggregate.
   */
  where?: Prisma.WplMatchInfoWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of WplMatchInfos to fetch.
   */
  orderBy?:
    | Prisma.WplMatchInfoOrderByWithRelationInput
    | Prisma.WplMatchInfoOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the start position
   */
  cursor?: Prisma.WplMatchInfoWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` WplMatchInfos from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` WplMatchInfos.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Count returned WplMatchInfos
   **/
  _count?: true | WplMatchInfoCountAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to average
   **/
  _avg?: WplMatchInfoAvgAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to sum
   **/
  _sum?: WplMatchInfoSumAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the minimum value
   **/
  _min?: WplMatchInfoMinAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the maximum value
   **/
  _max?: WplMatchInfoMaxAggregateInputType;
};

export type GetWplMatchInfoAggregateType<T extends WplMatchInfoAggregateArgs> = {
  [P in keyof T & keyof AggregateWplMatchInfo]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateWplMatchInfo[P]>
    : Prisma.GetScalarType<T[P], AggregateWplMatchInfo[P]>;
};

export type WplMatchInfoGroupByArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.WplMatchInfoWhereInput;
  orderBy?:
    | Prisma.WplMatchInfoOrderByWithAggregationInput
    | Prisma.WplMatchInfoOrderByWithAggregationInput[];
  by: Prisma.WplMatchInfoScalarFieldEnum[] | Prisma.WplMatchInfoScalarFieldEnum;
  having?: Prisma.WplMatchInfoScalarWhereWithAggregatesInput;
  take?: number;
  skip?: number;
  _count?: WplMatchInfoCountAggregateInputType | true;
  _avg?: WplMatchInfoAvgAggregateInputType;
  _sum?: WplMatchInfoSumAggregateInputType;
  _min?: WplMatchInfoMinAggregateInputType;
  _max?: WplMatchInfoMaxAggregateInputType;
};

export type WplMatchInfoGroupByOutputType = {
  id: number;
  league: string;
  version: string;
  ballsPerOver: number;
  gender: string;
  season: string;
  date: Date;
  event: string;
  matchNumber: number;
  venue: string;
  city: string;
  tossWinner: string;
  tossDecision: string;
  playerOfMatch: string | null;
  winner: string | null;
  winnerRuns: number | null;
  winnerWickets: number | null;
  _count: WplMatchInfoCountAggregateOutputType | null;
  _avg: WplMatchInfoAvgAggregateOutputType | null;
  _sum: WplMatchInfoSumAggregateOutputType | null;
  _min: WplMatchInfoMinAggregateOutputType | null;
  _max: WplMatchInfoMaxAggregateOutputType | null;
};

type GetWplMatchInfoGroupByPayload<T extends WplMatchInfoGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<WplMatchInfoGroupByOutputType, T['by']> & {
      [P in keyof T & keyof WplMatchInfoGroupByOutputType]: P extends '_count'
        ? T[P] extends boolean
          ? number
          : Prisma.GetScalarType<T[P], WplMatchInfoGroupByOutputType[P]>
        : Prisma.GetScalarType<T[P], WplMatchInfoGroupByOutputType[P]>;
    }
  >
>;

export type WplMatchInfoWhereInput = {
  AND?: Prisma.WplMatchInfoWhereInput | Prisma.WplMatchInfoWhereInput[];
  OR?: Prisma.WplMatchInfoWhereInput[];
  NOT?: Prisma.WplMatchInfoWhereInput | Prisma.WplMatchInfoWhereInput[];
  id?: Prisma.IntFilter<'WplMatchInfo'> | number;
  league?: Prisma.StringFilter<'WplMatchInfo'> | string;
  version?: Prisma.StringFilter<'WplMatchInfo'> | string;
  ballsPerOver?: Prisma.IntFilter<'WplMatchInfo'> | number;
  gender?: Prisma.StringFilter<'WplMatchInfo'> | string;
  season?: Prisma.StringFilter<'WplMatchInfo'> | string;
  date?: Prisma.DateTimeFilter<'WplMatchInfo'> | Date | string;
  event?: Prisma.StringFilter<'WplMatchInfo'> | string;
  matchNumber?: Prisma.IntFilter<'WplMatchInfo'> | number;
  venue?: Prisma.StringFilter<'WplMatchInfo'> | string;
  city?: Prisma.StringFilter<'WplMatchInfo'> | string;
  tossWinner?: Prisma.StringFilter<'WplMatchInfo'> | string;
  tossDecision?: Prisma.StringFilter<'WplMatchInfo'> | string;
  playerOfMatch?: Prisma.StringNullableFilter<'WplMatchInfo'> | string | null;
  winner?: Prisma.StringNullableFilter<'WplMatchInfo'> | string | null;
  winnerRuns?: Prisma.IntNullableFilter<'WplMatchInfo'> | number | null;
  winnerWickets?: Prisma.IntNullableFilter<'WplMatchInfo'> | number | null;
  teams?: Prisma.WplTeamListRelationFilter;
  players?: Prisma.WplPlayerListRelationFilter;
  officials?: Prisma.WplOfficialListRelationFilter;
  peopleRegistry?: Prisma.WplPersonRegistryListRelationFilter;
};

export type WplMatchInfoOrderByWithRelationInput = {
  id?: Prisma.SortOrder;
  league?: Prisma.SortOrder;
  version?: Prisma.SortOrder;
  ballsPerOver?: Prisma.SortOrder;
  gender?: Prisma.SortOrder;
  season?: Prisma.SortOrder;
  date?: Prisma.SortOrder;
  event?: Prisma.SortOrder;
  matchNumber?: Prisma.SortOrder;
  venue?: Prisma.SortOrder;
  city?: Prisma.SortOrder;
  tossWinner?: Prisma.SortOrder;
  tossDecision?: Prisma.SortOrder;
  playerOfMatch?: Prisma.SortOrderInput | Prisma.SortOrder;
  winner?: Prisma.SortOrderInput | Prisma.SortOrder;
  winnerRuns?: Prisma.SortOrderInput | Prisma.SortOrder;
  winnerWickets?: Prisma.SortOrderInput | Prisma.SortOrder;
  teams?: Prisma.WplTeamOrderByRelationAggregateInput;
  players?: Prisma.WplPlayerOrderByRelationAggregateInput;
  officials?: Prisma.WplOfficialOrderByRelationAggregateInput;
  peopleRegistry?: Prisma.WplPersonRegistryOrderByRelationAggregateInput;
};

export type WplMatchInfoWhereUniqueInput = Prisma.AtLeast<
  {
    id?: number;
    AND?: Prisma.WplMatchInfoWhereInput | Prisma.WplMatchInfoWhereInput[];
    OR?: Prisma.WplMatchInfoWhereInput[];
    NOT?: Prisma.WplMatchInfoWhereInput | Prisma.WplMatchInfoWhereInput[];
    league?: Prisma.StringFilter<'WplMatchInfo'> | string;
    version?: Prisma.StringFilter<'WplMatchInfo'> | string;
    ballsPerOver?: Prisma.IntFilter<'WplMatchInfo'> | number;
    gender?: Prisma.StringFilter<'WplMatchInfo'> | string;
    season?: Prisma.StringFilter<'WplMatchInfo'> | string;
    date?: Prisma.DateTimeFilter<'WplMatchInfo'> | Date | string;
    event?: Prisma.StringFilter<'WplMatchInfo'> | string;
    matchNumber?: Prisma.IntFilter<'WplMatchInfo'> | number;
    venue?: Prisma.StringFilter<'WplMatchInfo'> | string;
    city?: Prisma.StringFilter<'WplMatchInfo'> | string;
    tossWinner?: Prisma.StringFilter<'WplMatchInfo'> | string;
    tossDecision?: Prisma.StringFilter<'WplMatchInfo'> | string;
    playerOfMatch?: Prisma.StringNullableFilter<'WplMatchInfo'> | string | null;
    winner?: Prisma.StringNullableFilter<'WplMatchInfo'> | string | null;
    winnerRuns?: Prisma.IntNullableFilter<'WplMatchInfo'> | number | null;
    winnerWickets?: Prisma.IntNullableFilter<'WplMatchInfo'> | number | null;
    teams?: Prisma.WplTeamListRelationFilter;
    players?: Prisma.WplPlayerListRelationFilter;
    officials?: Prisma.WplOfficialListRelationFilter;
    peopleRegistry?: Prisma.WplPersonRegistryListRelationFilter;
  },
  'id'
>;

export type WplMatchInfoOrderByWithAggregationInput = {
  id?: Prisma.SortOrder;
  league?: Prisma.SortOrder;
  version?: Prisma.SortOrder;
  ballsPerOver?: Prisma.SortOrder;
  gender?: Prisma.SortOrder;
  season?: Prisma.SortOrder;
  date?: Prisma.SortOrder;
  event?: Prisma.SortOrder;
  matchNumber?: Prisma.SortOrder;
  venue?: Prisma.SortOrder;
  city?: Prisma.SortOrder;
  tossWinner?: Prisma.SortOrder;
  tossDecision?: Prisma.SortOrder;
  playerOfMatch?: Prisma.SortOrderInput | Prisma.SortOrder;
  winner?: Prisma.SortOrderInput | Prisma.SortOrder;
  winnerRuns?: Prisma.SortOrderInput | Prisma.SortOrder;
  winnerWickets?: Prisma.SortOrderInput | Prisma.SortOrder;
  _count?: Prisma.WplMatchInfoCountOrderByAggregateInput;
  _avg?: Prisma.WplMatchInfoAvgOrderByAggregateInput;
  _max?: Prisma.WplMatchInfoMaxOrderByAggregateInput;
  _min?: Prisma.WplMatchInfoMinOrderByAggregateInput;
  _sum?: Prisma.WplMatchInfoSumOrderByAggregateInput;
};

export type WplMatchInfoScalarWhereWithAggregatesInput = {
  AND?:
    | Prisma.WplMatchInfoScalarWhereWithAggregatesInput
    | Prisma.WplMatchInfoScalarWhereWithAggregatesInput[];
  OR?: Prisma.WplMatchInfoScalarWhereWithAggregatesInput[];
  NOT?:
    | Prisma.WplMatchInfoScalarWhereWithAggregatesInput
    | Prisma.WplMatchInfoScalarWhereWithAggregatesInput[];
  id?: Prisma.IntWithAggregatesFilter<'WplMatchInfo'> | number;
  league?: Prisma.StringWithAggregatesFilter<'WplMatchInfo'> | string;
  version?: Prisma.StringWithAggregatesFilter<'WplMatchInfo'> | string;
  ballsPerOver?: Prisma.IntWithAggregatesFilter<'WplMatchInfo'> | number;
  gender?: Prisma.StringWithAggregatesFilter<'WplMatchInfo'> | string;
  season?: Prisma.StringWithAggregatesFilter<'WplMatchInfo'> | string;
  date?: Prisma.DateTimeWithAggregatesFilter<'WplMatchInfo'> | Date | string;
  event?: Prisma.StringWithAggregatesFilter<'WplMatchInfo'> | string;
  matchNumber?: Prisma.IntWithAggregatesFilter<'WplMatchInfo'> | number;
  venue?: Prisma.StringWithAggregatesFilter<'WplMatchInfo'> | string;
  city?: Prisma.StringWithAggregatesFilter<'WplMatchInfo'> | string;
  tossWinner?: Prisma.StringWithAggregatesFilter<'WplMatchInfo'> | string;
  tossDecision?: Prisma.StringWithAggregatesFilter<'WplMatchInfo'> | string;
  playerOfMatch?: Prisma.StringNullableWithAggregatesFilter<'WplMatchInfo'> | string | null;
  winner?: Prisma.StringNullableWithAggregatesFilter<'WplMatchInfo'> | string | null;
  winnerRuns?: Prisma.IntNullableWithAggregatesFilter<'WplMatchInfo'> | number | null;
  winnerWickets?: Prisma.IntNullableWithAggregatesFilter<'WplMatchInfo'> | number | null;
};

export type WplMatchInfoCreateInput = {
  id: number;
  league?: string;
  version: string;
  ballsPerOver: number;
  gender: string;
  season: string;
  date: Date | string;
  event: string;
  matchNumber: number;
  venue: string;
  city: string;
  tossWinner: string;
  tossDecision: string;
  playerOfMatch?: string | null;
  winner?: string | null;
  winnerRuns?: number | null;
  winnerWickets?: number | null;
  teams?: Prisma.WplTeamCreateNestedManyWithoutMatchInfoInput;
  players?: Prisma.WplPlayerCreateNestedManyWithoutMatchInfoInput;
  officials?: Prisma.WplOfficialCreateNestedManyWithoutMatchInfoInput;
  peopleRegistry?: Prisma.WplPersonRegistryCreateNestedManyWithoutMatchInfoInput;
};

export type WplMatchInfoUncheckedCreateInput = {
  id: number;
  league?: string;
  version: string;
  ballsPerOver: number;
  gender: string;
  season: string;
  date: Date | string;
  event: string;
  matchNumber: number;
  venue: string;
  city: string;
  tossWinner: string;
  tossDecision: string;
  playerOfMatch?: string | null;
  winner?: string | null;
  winnerRuns?: number | null;
  winnerWickets?: number | null;
  teams?: Prisma.WplTeamUncheckedCreateNestedManyWithoutMatchInfoInput;
  players?: Prisma.WplPlayerUncheckedCreateNestedManyWithoutMatchInfoInput;
  officials?: Prisma.WplOfficialUncheckedCreateNestedManyWithoutMatchInfoInput;
  peopleRegistry?: Prisma.WplPersonRegistryUncheckedCreateNestedManyWithoutMatchInfoInput;
};

export type WplMatchInfoUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  league?: Prisma.StringFieldUpdateOperationsInput | string;
  version?: Prisma.StringFieldUpdateOperationsInput | string;
  ballsPerOver?: Prisma.IntFieldUpdateOperationsInput | number;
  gender?: Prisma.StringFieldUpdateOperationsInput | string;
  season?: Prisma.StringFieldUpdateOperationsInput | string;
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  event?: Prisma.StringFieldUpdateOperationsInput | string;
  matchNumber?: Prisma.IntFieldUpdateOperationsInput | number;
  venue?: Prisma.StringFieldUpdateOperationsInput | string;
  city?: Prisma.StringFieldUpdateOperationsInput | string;
  tossWinner?: Prisma.StringFieldUpdateOperationsInput | string;
  tossDecision?: Prisma.StringFieldUpdateOperationsInput | string;
  playerOfMatch?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winner?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winnerRuns?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  winnerWickets?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  teams?: Prisma.WplTeamUpdateManyWithoutMatchInfoNestedInput;
  players?: Prisma.WplPlayerUpdateManyWithoutMatchInfoNestedInput;
  officials?: Prisma.WplOfficialUpdateManyWithoutMatchInfoNestedInput;
  peopleRegistry?: Prisma.WplPersonRegistryUpdateManyWithoutMatchInfoNestedInput;
};

export type WplMatchInfoUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  league?: Prisma.StringFieldUpdateOperationsInput | string;
  version?: Prisma.StringFieldUpdateOperationsInput | string;
  ballsPerOver?: Prisma.IntFieldUpdateOperationsInput | number;
  gender?: Prisma.StringFieldUpdateOperationsInput | string;
  season?: Prisma.StringFieldUpdateOperationsInput | string;
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  event?: Prisma.StringFieldUpdateOperationsInput | string;
  matchNumber?: Prisma.IntFieldUpdateOperationsInput | number;
  venue?: Prisma.StringFieldUpdateOperationsInput | string;
  city?: Prisma.StringFieldUpdateOperationsInput | string;
  tossWinner?: Prisma.StringFieldUpdateOperationsInput | string;
  tossDecision?: Prisma.StringFieldUpdateOperationsInput | string;
  playerOfMatch?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winner?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winnerRuns?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  winnerWickets?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  teams?: Prisma.WplTeamUncheckedUpdateManyWithoutMatchInfoNestedInput;
  players?: Prisma.WplPlayerUncheckedUpdateManyWithoutMatchInfoNestedInput;
  officials?: Prisma.WplOfficialUncheckedUpdateManyWithoutMatchInfoNestedInput;
  peopleRegistry?: Prisma.WplPersonRegistryUncheckedUpdateManyWithoutMatchInfoNestedInput;
};

export type WplMatchInfoCreateManyInput = {
  id: number;
  league?: string;
  version: string;
  ballsPerOver: number;
  gender: string;
  season: string;
  date: Date | string;
  event: string;
  matchNumber: number;
  venue: string;
  city: string;
  tossWinner: string;
  tossDecision: string;
  playerOfMatch?: string | null;
  winner?: string | null;
  winnerRuns?: number | null;
  winnerWickets?: number | null;
};

export type WplMatchInfoUpdateManyMutationInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  league?: Prisma.StringFieldUpdateOperationsInput | string;
  version?: Prisma.StringFieldUpdateOperationsInput | string;
  ballsPerOver?: Prisma.IntFieldUpdateOperationsInput | number;
  gender?: Prisma.StringFieldUpdateOperationsInput | string;
  season?: Prisma.StringFieldUpdateOperationsInput | string;
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  event?: Prisma.StringFieldUpdateOperationsInput | string;
  matchNumber?: Prisma.IntFieldUpdateOperationsInput | number;
  venue?: Prisma.StringFieldUpdateOperationsInput | string;
  city?: Prisma.StringFieldUpdateOperationsInput | string;
  tossWinner?: Prisma.StringFieldUpdateOperationsInput | string;
  tossDecision?: Prisma.StringFieldUpdateOperationsInput | string;
  playerOfMatch?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winner?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winnerRuns?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  winnerWickets?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
};

export type WplMatchInfoUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  league?: Prisma.StringFieldUpdateOperationsInput | string;
  version?: Prisma.StringFieldUpdateOperationsInput | string;
  ballsPerOver?: Prisma.IntFieldUpdateOperationsInput | number;
  gender?: Prisma.StringFieldUpdateOperationsInput | string;
  season?: Prisma.StringFieldUpdateOperationsInput | string;
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  event?: Prisma.StringFieldUpdateOperationsInput | string;
  matchNumber?: Prisma.IntFieldUpdateOperationsInput | number;
  venue?: Prisma.StringFieldUpdateOperationsInput | string;
  city?: Prisma.StringFieldUpdateOperationsInput | string;
  tossWinner?: Prisma.StringFieldUpdateOperationsInput | string;
  tossDecision?: Prisma.StringFieldUpdateOperationsInput | string;
  playerOfMatch?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winner?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winnerRuns?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  winnerWickets?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
};

export type WplMatchInfoCountOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  league?: Prisma.SortOrder;
  version?: Prisma.SortOrder;
  ballsPerOver?: Prisma.SortOrder;
  gender?: Prisma.SortOrder;
  season?: Prisma.SortOrder;
  date?: Prisma.SortOrder;
  event?: Prisma.SortOrder;
  matchNumber?: Prisma.SortOrder;
  venue?: Prisma.SortOrder;
  city?: Prisma.SortOrder;
  tossWinner?: Prisma.SortOrder;
  tossDecision?: Prisma.SortOrder;
  playerOfMatch?: Prisma.SortOrder;
  winner?: Prisma.SortOrder;
  winnerRuns?: Prisma.SortOrder;
  winnerWickets?: Prisma.SortOrder;
};

export type WplMatchInfoAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  ballsPerOver?: Prisma.SortOrder;
  matchNumber?: Prisma.SortOrder;
  winnerRuns?: Prisma.SortOrder;
  winnerWickets?: Prisma.SortOrder;
};

export type WplMatchInfoMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  league?: Prisma.SortOrder;
  version?: Prisma.SortOrder;
  ballsPerOver?: Prisma.SortOrder;
  gender?: Prisma.SortOrder;
  season?: Prisma.SortOrder;
  date?: Prisma.SortOrder;
  event?: Prisma.SortOrder;
  matchNumber?: Prisma.SortOrder;
  venue?: Prisma.SortOrder;
  city?: Prisma.SortOrder;
  tossWinner?: Prisma.SortOrder;
  tossDecision?: Prisma.SortOrder;
  playerOfMatch?: Prisma.SortOrder;
  winner?: Prisma.SortOrder;
  winnerRuns?: Prisma.SortOrder;
  winnerWickets?: Prisma.SortOrder;
};

export type WplMatchInfoMinOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  league?: Prisma.SortOrder;
  version?: Prisma.SortOrder;
  ballsPerOver?: Prisma.SortOrder;
  gender?: Prisma.SortOrder;
  season?: Prisma.SortOrder;
  date?: Prisma.SortOrder;
  event?: Prisma.SortOrder;
  matchNumber?: Prisma.SortOrder;
  venue?: Prisma.SortOrder;
  city?: Prisma.SortOrder;
  tossWinner?: Prisma.SortOrder;
  tossDecision?: Prisma.SortOrder;
  playerOfMatch?: Prisma.SortOrder;
  winner?: Prisma.SortOrder;
  winnerRuns?: Prisma.SortOrder;
  winnerWickets?: Prisma.SortOrder;
};

export type WplMatchInfoSumOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  ballsPerOver?: Prisma.SortOrder;
  matchNumber?: Prisma.SortOrder;
  winnerRuns?: Prisma.SortOrder;
  winnerWickets?: Prisma.SortOrder;
};

export type WplMatchInfoScalarRelationFilter = {
  is?: Prisma.WplMatchInfoWhereInput;
  isNot?: Prisma.WplMatchInfoWhereInput;
};

export type NullableIntFieldUpdateOperationsInput = {
  set?: number | null;
  increment?: number;
  decrement?: number;
  multiply?: number;
  divide?: number;
};

export type WplMatchInfoCreateNestedOneWithoutTeamsInput = {
  create?: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutTeamsInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutTeamsInput
  >;
  connectOrCreate?: Prisma.WplMatchInfoCreateOrConnectWithoutTeamsInput;
  connect?: Prisma.WplMatchInfoWhereUniqueInput;
};

export type WplMatchInfoUpdateOneRequiredWithoutTeamsNestedInput = {
  create?: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutTeamsInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutTeamsInput
  >;
  connectOrCreate?: Prisma.WplMatchInfoCreateOrConnectWithoutTeamsInput;
  upsert?: Prisma.WplMatchInfoUpsertWithoutTeamsInput;
  connect?: Prisma.WplMatchInfoWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.WplMatchInfoUpdateToOneWithWhereWithoutTeamsInput,
      Prisma.WplMatchInfoUpdateWithoutTeamsInput
    >,
    Prisma.WplMatchInfoUncheckedUpdateWithoutTeamsInput
  >;
};

export type WplMatchInfoCreateNestedOneWithoutPlayersInput = {
  create?: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutPlayersInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutPlayersInput
  >;
  connectOrCreate?: Prisma.WplMatchInfoCreateOrConnectWithoutPlayersInput;
  connect?: Prisma.WplMatchInfoWhereUniqueInput;
};

export type WplMatchInfoUpdateOneRequiredWithoutPlayersNestedInput = {
  create?: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutPlayersInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutPlayersInput
  >;
  connectOrCreate?: Prisma.WplMatchInfoCreateOrConnectWithoutPlayersInput;
  upsert?: Prisma.WplMatchInfoUpsertWithoutPlayersInput;
  connect?: Prisma.WplMatchInfoWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.WplMatchInfoUpdateToOneWithWhereWithoutPlayersInput,
      Prisma.WplMatchInfoUpdateWithoutPlayersInput
    >,
    Prisma.WplMatchInfoUncheckedUpdateWithoutPlayersInput
  >;
};

export type WplMatchInfoCreateNestedOneWithoutOfficialsInput = {
  create?: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutOfficialsInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutOfficialsInput
  >;
  connectOrCreate?: Prisma.WplMatchInfoCreateOrConnectWithoutOfficialsInput;
  connect?: Prisma.WplMatchInfoWhereUniqueInput;
};

export type WplMatchInfoUpdateOneRequiredWithoutOfficialsNestedInput = {
  create?: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutOfficialsInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutOfficialsInput
  >;
  connectOrCreate?: Prisma.WplMatchInfoCreateOrConnectWithoutOfficialsInput;
  upsert?: Prisma.WplMatchInfoUpsertWithoutOfficialsInput;
  connect?: Prisma.WplMatchInfoWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.WplMatchInfoUpdateToOneWithWhereWithoutOfficialsInput,
      Prisma.WplMatchInfoUpdateWithoutOfficialsInput
    >,
    Prisma.WplMatchInfoUncheckedUpdateWithoutOfficialsInput
  >;
};

export type WplMatchInfoCreateNestedOneWithoutPeopleRegistryInput = {
  create?: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutPeopleRegistryInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutPeopleRegistryInput
  >;
  connectOrCreate?: Prisma.WplMatchInfoCreateOrConnectWithoutPeopleRegistryInput;
  connect?: Prisma.WplMatchInfoWhereUniqueInput;
};

export type WplMatchInfoUpdateOneRequiredWithoutPeopleRegistryNestedInput = {
  create?: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutPeopleRegistryInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutPeopleRegistryInput
  >;
  connectOrCreate?: Prisma.WplMatchInfoCreateOrConnectWithoutPeopleRegistryInput;
  upsert?: Prisma.WplMatchInfoUpsertWithoutPeopleRegistryInput;
  connect?: Prisma.WplMatchInfoWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.WplMatchInfoUpdateToOneWithWhereWithoutPeopleRegistryInput,
      Prisma.WplMatchInfoUpdateWithoutPeopleRegistryInput
    >,
    Prisma.WplMatchInfoUncheckedUpdateWithoutPeopleRegistryInput
  >;
};

export type WplMatchInfoCreateWithoutTeamsInput = {
  id: number;
  league?: string;
  version: string;
  ballsPerOver: number;
  gender: string;
  season: string;
  date: Date | string;
  event: string;
  matchNumber: number;
  venue: string;
  city: string;
  tossWinner: string;
  tossDecision: string;
  playerOfMatch?: string | null;
  winner?: string | null;
  winnerRuns?: number | null;
  winnerWickets?: number | null;
  players?: Prisma.WplPlayerCreateNestedManyWithoutMatchInfoInput;
  officials?: Prisma.WplOfficialCreateNestedManyWithoutMatchInfoInput;
  peopleRegistry?: Prisma.WplPersonRegistryCreateNestedManyWithoutMatchInfoInput;
};

export type WplMatchInfoUncheckedCreateWithoutTeamsInput = {
  id: number;
  league?: string;
  version: string;
  ballsPerOver: number;
  gender: string;
  season: string;
  date: Date | string;
  event: string;
  matchNumber: number;
  venue: string;
  city: string;
  tossWinner: string;
  tossDecision: string;
  playerOfMatch?: string | null;
  winner?: string | null;
  winnerRuns?: number | null;
  winnerWickets?: number | null;
  players?: Prisma.WplPlayerUncheckedCreateNestedManyWithoutMatchInfoInput;
  officials?: Prisma.WplOfficialUncheckedCreateNestedManyWithoutMatchInfoInput;
  peopleRegistry?: Prisma.WplPersonRegistryUncheckedCreateNestedManyWithoutMatchInfoInput;
};

export type WplMatchInfoCreateOrConnectWithoutTeamsInput = {
  where: Prisma.WplMatchInfoWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutTeamsInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutTeamsInput
  >;
};

export type WplMatchInfoUpsertWithoutTeamsInput = {
  update: Prisma.XOR<
    Prisma.WplMatchInfoUpdateWithoutTeamsInput,
    Prisma.WplMatchInfoUncheckedUpdateWithoutTeamsInput
  >;
  create: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutTeamsInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutTeamsInput
  >;
  where?: Prisma.WplMatchInfoWhereInput;
};

export type WplMatchInfoUpdateToOneWithWhereWithoutTeamsInput = {
  where?: Prisma.WplMatchInfoWhereInput;
  data: Prisma.XOR<
    Prisma.WplMatchInfoUpdateWithoutTeamsInput,
    Prisma.WplMatchInfoUncheckedUpdateWithoutTeamsInput
  >;
};

export type WplMatchInfoUpdateWithoutTeamsInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  league?: Prisma.StringFieldUpdateOperationsInput | string;
  version?: Prisma.StringFieldUpdateOperationsInput | string;
  ballsPerOver?: Prisma.IntFieldUpdateOperationsInput | number;
  gender?: Prisma.StringFieldUpdateOperationsInput | string;
  season?: Prisma.StringFieldUpdateOperationsInput | string;
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  event?: Prisma.StringFieldUpdateOperationsInput | string;
  matchNumber?: Prisma.IntFieldUpdateOperationsInput | number;
  venue?: Prisma.StringFieldUpdateOperationsInput | string;
  city?: Prisma.StringFieldUpdateOperationsInput | string;
  tossWinner?: Prisma.StringFieldUpdateOperationsInput | string;
  tossDecision?: Prisma.StringFieldUpdateOperationsInput | string;
  playerOfMatch?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winner?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winnerRuns?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  winnerWickets?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  players?: Prisma.WplPlayerUpdateManyWithoutMatchInfoNestedInput;
  officials?: Prisma.WplOfficialUpdateManyWithoutMatchInfoNestedInput;
  peopleRegistry?: Prisma.WplPersonRegistryUpdateManyWithoutMatchInfoNestedInput;
};

export type WplMatchInfoUncheckedUpdateWithoutTeamsInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  league?: Prisma.StringFieldUpdateOperationsInput | string;
  version?: Prisma.StringFieldUpdateOperationsInput | string;
  ballsPerOver?: Prisma.IntFieldUpdateOperationsInput | number;
  gender?: Prisma.StringFieldUpdateOperationsInput | string;
  season?: Prisma.StringFieldUpdateOperationsInput | string;
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  event?: Prisma.StringFieldUpdateOperationsInput | string;
  matchNumber?: Prisma.IntFieldUpdateOperationsInput | number;
  venue?: Prisma.StringFieldUpdateOperationsInput | string;
  city?: Prisma.StringFieldUpdateOperationsInput | string;
  tossWinner?: Prisma.StringFieldUpdateOperationsInput | string;
  tossDecision?: Prisma.StringFieldUpdateOperationsInput | string;
  playerOfMatch?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winner?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winnerRuns?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  winnerWickets?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  players?: Prisma.WplPlayerUncheckedUpdateManyWithoutMatchInfoNestedInput;
  officials?: Prisma.WplOfficialUncheckedUpdateManyWithoutMatchInfoNestedInput;
  peopleRegistry?: Prisma.WplPersonRegistryUncheckedUpdateManyWithoutMatchInfoNestedInput;
};

export type WplMatchInfoCreateWithoutPlayersInput = {
  id: number;
  league?: string;
  version: string;
  ballsPerOver: number;
  gender: string;
  season: string;
  date: Date | string;
  event: string;
  matchNumber: number;
  venue: string;
  city: string;
  tossWinner: string;
  tossDecision: string;
  playerOfMatch?: string | null;
  winner?: string | null;
  winnerRuns?: number | null;
  winnerWickets?: number | null;
  teams?: Prisma.WplTeamCreateNestedManyWithoutMatchInfoInput;
  officials?: Prisma.WplOfficialCreateNestedManyWithoutMatchInfoInput;
  peopleRegistry?: Prisma.WplPersonRegistryCreateNestedManyWithoutMatchInfoInput;
};

export type WplMatchInfoUncheckedCreateWithoutPlayersInput = {
  id: number;
  league?: string;
  version: string;
  ballsPerOver: number;
  gender: string;
  season: string;
  date: Date | string;
  event: string;
  matchNumber: number;
  venue: string;
  city: string;
  tossWinner: string;
  tossDecision: string;
  playerOfMatch?: string | null;
  winner?: string | null;
  winnerRuns?: number | null;
  winnerWickets?: number | null;
  teams?: Prisma.WplTeamUncheckedCreateNestedManyWithoutMatchInfoInput;
  officials?: Prisma.WplOfficialUncheckedCreateNestedManyWithoutMatchInfoInput;
  peopleRegistry?: Prisma.WplPersonRegistryUncheckedCreateNestedManyWithoutMatchInfoInput;
};

export type WplMatchInfoCreateOrConnectWithoutPlayersInput = {
  where: Prisma.WplMatchInfoWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutPlayersInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutPlayersInput
  >;
};

export type WplMatchInfoUpsertWithoutPlayersInput = {
  update: Prisma.XOR<
    Prisma.WplMatchInfoUpdateWithoutPlayersInput,
    Prisma.WplMatchInfoUncheckedUpdateWithoutPlayersInput
  >;
  create: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutPlayersInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutPlayersInput
  >;
  where?: Prisma.WplMatchInfoWhereInput;
};

export type WplMatchInfoUpdateToOneWithWhereWithoutPlayersInput = {
  where?: Prisma.WplMatchInfoWhereInput;
  data: Prisma.XOR<
    Prisma.WplMatchInfoUpdateWithoutPlayersInput,
    Prisma.WplMatchInfoUncheckedUpdateWithoutPlayersInput
  >;
};

export type WplMatchInfoUpdateWithoutPlayersInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  league?: Prisma.StringFieldUpdateOperationsInput | string;
  version?: Prisma.StringFieldUpdateOperationsInput | string;
  ballsPerOver?: Prisma.IntFieldUpdateOperationsInput | number;
  gender?: Prisma.StringFieldUpdateOperationsInput | string;
  season?: Prisma.StringFieldUpdateOperationsInput | string;
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  event?: Prisma.StringFieldUpdateOperationsInput | string;
  matchNumber?: Prisma.IntFieldUpdateOperationsInput | number;
  venue?: Prisma.StringFieldUpdateOperationsInput | string;
  city?: Prisma.StringFieldUpdateOperationsInput | string;
  tossWinner?: Prisma.StringFieldUpdateOperationsInput | string;
  tossDecision?: Prisma.StringFieldUpdateOperationsInput | string;
  playerOfMatch?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winner?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winnerRuns?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  winnerWickets?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  teams?: Prisma.WplTeamUpdateManyWithoutMatchInfoNestedInput;
  officials?: Prisma.WplOfficialUpdateManyWithoutMatchInfoNestedInput;
  peopleRegistry?: Prisma.WplPersonRegistryUpdateManyWithoutMatchInfoNestedInput;
};

export type WplMatchInfoUncheckedUpdateWithoutPlayersInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  league?: Prisma.StringFieldUpdateOperationsInput | string;
  version?: Prisma.StringFieldUpdateOperationsInput | string;
  ballsPerOver?: Prisma.IntFieldUpdateOperationsInput | number;
  gender?: Prisma.StringFieldUpdateOperationsInput | string;
  season?: Prisma.StringFieldUpdateOperationsInput | string;
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  event?: Prisma.StringFieldUpdateOperationsInput | string;
  matchNumber?: Prisma.IntFieldUpdateOperationsInput | number;
  venue?: Prisma.StringFieldUpdateOperationsInput | string;
  city?: Prisma.StringFieldUpdateOperationsInput | string;
  tossWinner?: Prisma.StringFieldUpdateOperationsInput | string;
  tossDecision?: Prisma.StringFieldUpdateOperationsInput | string;
  playerOfMatch?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winner?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winnerRuns?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  winnerWickets?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  teams?: Prisma.WplTeamUncheckedUpdateManyWithoutMatchInfoNestedInput;
  officials?: Prisma.WplOfficialUncheckedUpdateManyWithoutMatchInfoNestedInput;
  peopleRegistry?: Prisma.WplPersonRegistryUncheckedUpdateManyWithoutMatchInfoNestedInput;
};

export type WplMatchInfoCreateWithoutOfficialsInput = {
  id: number;
  league?: string;
  version: string;
  ballsPerOver: number;
  gender: string;
  season: string;
  date: Date | string;
  event: string;
  matchNumber: number;
  venue: string;
  city: string;
  tossWinner: string;
  tossDecision: string;
  playerOfMatch?: string | null;
  winner?: string | null;
  winnerRuns?: number | null;
  winnerWickets?: number | null;
  teams?: Prisma.WplTeamCreateNestedManyWithoutMatchInfoInput;
  players?: Prisma.WplPlayerCreateNestedManyWithoutMatchInfoInput;
  peopleRegistry?: Prisma.WplPersonRegistryCreateNestedManyWithoutMatchInfoInput;
};

export type WplMatchInfoUncheckedCreateWithoutOfficialsInput = {
  id: number;
  league?: string;
  version: string;
  ballsPerOver: number;
  gender: string;
  season: string;
  date: Date | string;
  event: string;
  matchNumber: number;
  venue: string;
  city: string;
  tossWinner: string;
  tossDecision: string;
  playerOfMatch?: string | null;
  winner?: string | null;
  winnerRuns?: number | null;
  winnerWickets?: number | null;
  teams?: Prisma.WplTeamUncheckedCreateNestedManyWithoutMatchInfoInput;
  players?: Prisma.WplPlayerUncheckedCreateNestedManyWithoutMatchInfoInput;
  peopleRegistry?: Prisma.WplPersonRegistryUncheckedCreateNestedManyWithoutMatchInfoInput;
};

export type WplMatchInfoCreateOrConnectWithoutOfficialsInput = {
  where: Prisma.WplMatchInfoWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutOfficialsInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutOfficialsInput
  >;
};

export type WplMatchInfoUpsertWithoutOfficialsInput = {
  update: Prisma.XOR<
    Prisma.WplMatchInfoUpdateWithoutOfficialsInput,
    Prisma.WplMatchInfoUncheckedUpdateWithoutOfficialsInput
  >;
  create: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutOfficialsInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutOfficialsInput
  >;
  where?: Prisma.WplMatchInfoWhereInput;
};

export type WplMatchInfoUpdateToOneWithWhereWithoutOfficialsInput = {
  where?: Prisma.WplMatchInfoWhereInput;
  data: Prisma.XOR<
    Prisma.WplMatchInfoUpdateWithoutOfficialsInput,
    Prisma.WplMatchInfoUncheckedUpdateWithoutOfficialsInput
  >;
};

export type WplMatchInfoUpdateWithoutOfficialsInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  league?: Prisma.StringFieldUpdateOperationsInput | string;
  version?: Prisma.StringFieldUpdateOperationsInput | string;
  ballsPerOver?: Prisma.IntFieldUpdateOperationsInput | number;
  gender?: Prisma.StringFieldUpdateOperationsInput | string;
  season?: Prisma.StringFieldUpdateOperationsInput | string;
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  event?: Prisma.StringFieldUpdateOperationsInput | string;
  matchNumber?: Prisma.IntFieldUpdateOperationsInput | number;
  venue?: Prisma.StringFieldUpdateOperationsInput | string;
  city?: Prisma.StringFieldUpdateOperationsInput | string;
  tossWinner?: Prisma.StringFieldUpdateOperationsInput | string;
  tossDecision?: Prisma.StringFieldUpdateOperationsInput | string;
  playerOfMatch?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winner?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winnerRuns?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  winnerWickets?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  teams?: Prisma.WplTeamUpdateManyWithoutMatchInfoNestedInput;
  players?: Prisma.WplPlayerUpdateManyWithoutMatchInfoNestedInput;
  peopleRegistry?: Prisma.WplPersonRegistryUpdateManyWithoutMatchInfoNestedInput;
};

export type WplMatchInfoUncheckedUpdateWithoutOfficialsInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  league?: Prisma.StringFieldUpdateOperationsInput | string;
  version?: Prisma.StringFieldUpdateOperationsInput | string;
  ballsPerOver?: Prisma.IntFieldUpdateOperationsInput | number;
  gender?: Prisma.StringFieldUpdateOperationsInput | string;
  season?: Prisma.StringFieldUpdateOperationsInput | string;
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  event?: Prisma.StringFieldUpdateOperationsInput | string;
  matchNumber?: Prisma.IntFieldUpdateOperationsInput | number;
  venue?: Prisma.StringFieldUpdateOperationsInput | string;
  city?: Prisma.StringFieldUpdateOperationsInput | string;
  tossWinner?: Prisma.StringFieldUpdateOperationsInput | string;
  tossDecision?: Prisma.StringFieldUpdateOperationsInput | string;
  playerOfMatch?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winner?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winnerRuns?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  winnerWickets?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  teams?: Prisma.WplTeamUncheckedUpdateManyWithoutMatchInfoNestedInput;
  players?: Prisma.WplPlayerUncheckedUpdateManyWithoutMatchInfoNestedInput;
  peopleRegistry?: Prisma.WplPersonRegistryUncheckedUpdateManyWithoutMatchInfoNestedInput;
};

export type WplMatchInfoCreateWithoutPeopleRegistryInput = {
  id: number;
  league?: string;
  version: string;
  ballsPerOver: number;
  gender: string;
  season: string;
  date: Date | string;
  event: string;
  matchNumber: number;
  venue: string;
  city: string;
  tossWinner: string;
  tossDecision: string;
  playerOfMatch?: string | null;
  winner?: string | null;
  winnerRuns?: number | null;
  winnerWickets?: number | null;
  teams?: Prisma.WplTeamCreateNestedManyWithoutMatchInfoInput;
  players?: Prisma.WplPlayerCreateNestedManyWithoutMatchInfoInput;
  officials?: Prisma.WplOfficialCreateNestedManyWithoutMatchInfoInput;
};

export type WplMatchInfoUncheckedCreateWithoutPeopleRegistryInput = {
  id: number;
  league?: string;
  version: string;
  ballsPerOver: number;
  gender: string;
  season: string;
  date: Date | string;
  event: string;
  matchNumber: number;
  venue: string;
  city: string;
  tossWinner: string;
  tossDecision: string;
  playerOfMatch?: string | null;
  winner?: string | null;
  winnerRuns?: number | null;
  winnerWickets?: number | null;
  teams?: Prisma.WplTeamUncheckedCreateNestedManyWithoutMatchInfoInput;
  players?: Prisma.WplPlayerUncheckedCreateNestedManyWithoutMatchInfoInput;
  officials?: Prisma.WplOfficialUncheckedCreateNestedManyWithoutMatchInfoInput;
};

export type WplMatchInfoCreateOrConnectWithoutPeopleRegistryInput = {
  where: Prisma.WplMatchInfoWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutPeopleRegistryInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutPeopleRegistryInput
  >;
};

export type WplMatchInfoUpsertWithoutPeopleRegistryInput = {
  update: Prisma.XOR<
    Prisma.WplMatchInfoUpdateWithoutPeopleRegistryInput,
    Prisma.WplMatchInfoUncheckedUpdateWithoutPeopleRegistryInput
  >;
  create: Prisma.XOR<
    Prisma.WplMatchInfoCreateWithoutPeopleRegistryInput,
    Prisma.WplMatchInfoUncheckedCreateWithoutPeopleRegistryInput
  >;
  where?: Prisma.WplMatchInfoWhereInput;
};

export type WplMatchInfoUpdateToOneWithWhereWithoutPeopleRegistryInput = {
  where?: Prisma.WplMatchInfoWhereInput;
  data: Prisma.XOR<
    Prisma.WplMatchInfoUpdateWithoutPeopleRegistryInput,
    Prisma.WplMatchInfoUncheckedUpdateWithoutPeopleRegistryInput
  >;
};

export type WplMatchInfoUpdateWithoutPeopleRegistryInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  league?: Prisma.StringFieldUpdateOperationsInput | string;
  version?: Prisma.StringFieldUpdateOperationsInput | string;
  ballsPerOver?: Prisma.IntFieldUpdateOperationsInput | number;
  gender?: Prisma.StringFieldUpdateOperationsInput | string;
  season?: Prisma.StringFieldUpdateOperationsInput | string;
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  event?: Prisma.StringFieldUpdateOperationsInput | string;
  matchNumber?: Prisma.IntFieldUpdateOperationsInput | number;
  venue?: Prisma.StringFieldUpdateOperationsInput | string;
  city?: Prisma.StringFieldUpdateOperationsInput | string;
  tossWinner?: Prisma.StringFieldUpdateOperationsInput | string;
  tossDecision?: Prisma.StringFieldUpdateOperationsInput | string;
  playerOfMatch?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winner?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winnerRuns?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  winnerWickets?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  teams?: Prisma.WplTeamUpdateManyWithoutMatchInfoNestedInput;
  players?: Prisma.WplPlayerUpdateManyWithoutMatchInfoNestedInput;
  officials?: Prisma.WplOfficialUpdateManyWithoutMatchInfoNestedInput;
};

export type WplMatchInfoUncheckedUpdateWithoutPeopleRegistryInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number;
  league?: Prisma.StringFieldUpdateOperationsInput | string;
  version?: Prisma.StringFieldUpdateOperationsInput | string;
  ballsPerOver?: Prisma.IntFieldUpdateOperationsInput | number;
  gender?: Prisma.StringFieldUpdateOperationsInput | string;
  season?: Prisma.StringFieldUpdateOperationsInput | string;
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  event?: Prisma.StringFieldUpdateOperationsInput | string;
  matchNumber?: Prisma.IntFieldUpdateOperationsInput | number;
  venue?: Prisma.StringFieldUpdateOperationsInput | string;
  city?: Prisma.StringFieldUpdateOperationsInput | string;
  tossWinner?: Prisma.StringFieldUpdateOperationsInput | string;
  tossDecision?: Prisma.StringFieldUpdateOperationsInput | string;
  playerOfMatch?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winner?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  winnerRuns?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  winnerWickets?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  teams?: Prisma.WplTeamUncheckedUpdateManyWithoutMatchInfoNestedInput;
  players?: Prisma.WplPlayerUncheckedUpdateManyWithoutMatchInfoNestedInput;
  officials?: Prisma.WplOfficialUncheckedUpdateManyWithoutMatchInfoNestedInput;
};

/**
 * Count Type WplMatchInfoCountOutputType
 */

export type WplMatchInfoCountOutputType = {
  teams: number;
  players: number;
  officials: number;
  peopleRegistry: number;
};

export type WplMatchInfoCountOutputTypeSelect<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  teams?: boolean | WplMatchInfoCountOutputTypeCountTeamsArgs;
  players?: boolean | WplMatchInfoCountOutputTypeCountPlayersArgs;
  officials?: boolean | WplMatchInfoCountOutputTypeCountOfficialsArgs;
  peopleRegistry?: boolean | WplMatchInfoCountOutputTypeCountPeopleRegistryArgs;
};

/**
 * WplMatchInfoCountOutputType without action
 */
export type WplMatchInfoCountOutputTypeDefaultArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplMatchInfoCountOutputType
   */
  select?: Prisma.WplMatchInfoCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * WplMatchInfoCountOutputType without action
 */
export type WplMatchInfoCountOutputTypeCountTeamsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.WplTeamWhereInput;
};

/**
 * WplMatchInfoCountOutputType without action
 */
export type WplMatchInfoCountOutputTypeCountPlayersArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.WplPlayerWhereInput;
};

/**
 * WplMatchInfoCountOutputType without action
 */
export type WplMatchInfoCountOutputTypeCountOfficialsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.WplOfficialWhereInput;
};

/**
 * WplMatchInfoCountOutputType without action
 */
export type WplMatchInfoCountOutputTypeCountPeopleRegistryArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.WplPersonRegistryWhereInput;
};

export type WplMatchInfoSelect<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    league?: boolean;
    version?: boolean;
    ballsPerOver?: boolean;
    gender?: boolean;
    season?: boolean;
    date?: boolean;
    event?: boolean;
    matchNumber?: boolean;
    venue?: boolean;
    city?: boolean;
    tossWinner?: boolean;
    tossDecision?: boolean;
    playerOfMatch?: boolean;
    winner?: boolean;
    winnerRuns?: boolean;
    winnerWickets?: boolean;
    teams?: boolean | Prisma.WplMatchInfo$teamsArgs<ExtArgs>;
    players?: boolean | Prisma.WplMatchInfo$playersArgs<ExtArgs>;
    officials?: boolean | Prisma.WplMatchInfo$officialsArgs<ExtArgs>;
    peopleRegistry?: boolean | Prisma.WplMatchInfo$peopleRegistryArgs<ExtArgs>;
    _count?: boolean | Prisma.WplMatchInfoCountOutputTypeDefaultArgs<ExtArgs>;
  },
  ExtArgs['result']['wplMatchInfo']
>;

export type WplMatchInfoSelectCreateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    league?: boolean;
    version?: boolean;
    ballsPerOver?: boolean;
    gender?: boolean;
    season?: boolean;
    date?: boolean;
    event?: boolean;
    matchNumber?: boolean;
    venue?: boolean;
    city?: boolean;
    tossWinner?: boolean;
    tossDecision?: boolean;
    playerOfMatch?: boolean;
    winner?: boolean;
    winnerRuns?: boolean;
    winnerWickets?: boolean;
  },
  ExtArgs['result']['wplMatchInfo']
>;

export type WplMatchInfoSelectUpdateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    league?: boolean;
    version?: boolean;
    ballsPerOver?: boolean;
    gender?: boolean;
    season?: boolean;
    date?: boolean;
    event?: boolean;
    matchNumber?: boolean;
    venue?: boolean;
    city?: boolean;
    tossWinner?: boolean;
    tossDecision?: boolean;
    playerOfMatch?: boolean;
    winner?: boolean;
    winnerRuns?: boolean;
    winnerWickets?: boolean;
  },
  ExtArgs['result']['wplMatchInfo']
>;

export type WplMatchInfoSelectScalar = {
  id?: boolean;
  league?: boolean;
  version?: boolean;
  ballsPerOver?: boolean;
  gender?: boolean;
  season?: boolean;
  date?: boolean;
  event?: boolean;
  matchNumber?: boolean;
  venue?: boolean;
  city?: boolean;
  tossWinner?: boolean;
  tossDecision?: boolean;
  playerOfMatch?: boolean;
  winner?: boolean;
  winnerRuns?: boolean;
  winnerWickets?: boolean;
};

export type WplMatchInfoOmit<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
  | 'id'
  | 'league'
  | 'version'
  | 'ballsPerOver'
  | 'gender'
  | 'season'
  | 'date'
  | 'event'
  | 'matchNumber'
  | 'venue'
  | 'city'
  | 'tossWinner'
  | 'tossDecision'
  | 'playerOfMatch'
  | 'winner'
  | 'winnerRuns'
  | 'winnerWickets',
  ExtArgs['result']['wplMatchInfo']
>;
export type WplMatchInfoInclude<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  teams?: boolean | Prisma.WplMatchInfo$teamsArgs<ExtArgs>;
  players?: boolean | Prisma.WplMatchInfo$playersArgs<ExtArgs>;
  officials?: boolean | Prisma.WplMatchInfo$officialsArgs<ExtArgs>;
  peopleRegistry?: boolean | Prisma.WplMatchInfo$peopleRegistryArgs<ExtArgs>;
  _count?: boolean | Prisma.WplMatchInfoCountOutputTypeDefaultArgs<ExtArgs>;
};
export type WplMatchInfoIncludeCreateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {};
export type WplMatchInfoIncludeUpdateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {};

export type $WplMatchInfoPayload<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  name: 'WplMatchInfo';
  objects: {
    teams: Prisma.$WplTeamPayload<ExtArgs>[];
    players: Prisma.$WplPlayerPayload<ExtArgs>[];
    officials: Prisma.$WplOfficialPayload<ExtArgs>[];
    peopleRegistry: Prisma.$WplPersonRegistryPayload<ExtArgs>[];
  };
  scalars: runtime.Types.Extensions.GetPayloadResult<
    {
      id: number;
      league: string;
      version: string;
      ballsPerOver: number;
      gender: string;
      season: string;
      date: Date;
      event: string;
      matchNumber: number;
      venue: string;
      city: string;
      tossWinner: string;
      tossDecision: string;
      playerOfMatch: string | null;
      winner: string | null;
      winnerRuns: number | null;
      winnerWickets: number | null;
    },
    ExtArgs['result']['wplMatchInfo']
  >;
  composites: {};
};

export type WplMatchInfoGetPayload<S extends boolean | null | undefined | WplMatchInfoDefaultArgs> =
  runtime.Types.Result.GetResult<Prisma.$WplMatchInfoPayload, S>;

export type WplMatchInfoCountArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<WplMatchInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
  select?: WplMatchInfoCountAggregateInputType | true;
};

export interface WplMatchInfoDelegate<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> {
  [K: symbol]: {
    types: Prisma.TypeMap<ExtArgs>['model']['WplMatchInfo'];
    meta: { name: 'WplMatchInfo' };
  };
  /**
   * Find zero or one WplMatchInfo that matches the filter.
   * @param {WplMatchInfoFindUniqueArgs} args - Arguments to find a WplMatchInfo
   * @example
   * // Get one WplMatchInfo
   * const wplMatchInfo = await prisma.wplMatchInfo.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends WplMatchInfoFindUniqueArgs>(
    args: Prisma.SelectSubset<T, WplMatchInfoFindUniqueArgs<ExtArgs>>,
  ): Prisma.Prisma__WplMatchInfoClient<
    runtime.Types.Result.GetResult<
      Prisma.$WplMatchInfoPayload<ExtArgs>,
      T,
      'findUnique',
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find one WplMatchInfo that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {WplMatchInfoFindUniqueOrThrowArgs} args - Arguments to find a WplMatchInfo
   * @example
   * // Get one WplMatchInfo
   * const wplMatchInfo = await prisma.wplMatchInfo.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends WplMatchInfoFindUniqueOrThrowArgs>(
    args: Prisma.SelectSubset<T, WplMatchInfoFindUniqueOrThrowArgs<ExtArgs>>,
  ): Prisma.Prisma__WplMatchInfoClient<
    runtime.Types.Result.GetResult<
      Prisma.$WplMatchInfoPayload<ExtArgs>,
      T,
      'findUniqueOrThrow',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first WplMatchInfo that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WplMatchInfoFindFirstArgs} args - Arguments to find a WplMatchInfo
   * @example
   * // Get one WplMatchInfo
   * const wplMatchInfo = await prisma.wplMatchInfo.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends WplMatchInfoFindFirstArgs>(
    args?: Prisma.SelectSubset<T, WplMatchInfoFindFirstArgs<ExtArgs>>,
  ): Prisma.Prisma__WplMatchInfoClient<
    runtime.Types.Result.GetResult<
      Prisma.$WplMatchInfoPayload<ExtArgs>,
      T,
      'findFirst',
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first WplMatchInfo that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WplMatchInfoFindFirstOrThrowArgs} args - Arguments to find a WplMatchInfo
   * @example
   * // Get one WplMatchInfo
   * const wplMatchInfo = await prisma.wplMatchInfo.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends WplMatchInfoFindFirstOrThrowArgs>(
    args?: Prisma.SelectSubset<T, WplMatchInfoFindFirstOrThrowArgs<ExtArgs>>,
  ): Prisma.Prisma__WplMatchInfoClient<
    runtime.Types.Result.GetResult<
      Prisma.$WplMatchInfoPayload<ExtArgs>,
      T,
      'findFirstOrThrow',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find zero or more WplMatchInfos that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WplMatchInfoFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all WplMatchInfos
   * const wplMatchInfos = await prisma.wplMatchInfo.findMany()
   *
   * // Get first 10 WplMatchInfos
   * const wplMatchInfos = await prisma.wplMatchInfo.findMany({ take: 10 })
   *
   * // Only select the `id`
   * const wplMatchInfoWithIdOnly = await prisma.wplMatchInfo.findMany({ select: { id: true } })
   *
   */
  findMany<T extends WplMatchInfoFindManyArgs>(
    args?: Prisma.SelectSubset<T, WplMatchInfoFindManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$WplMatchInfoPayload<ExtArgs>,
      T,
      'findMany',
      GlobalOmitOptions
    >
  >;

  /**
   * Create a WplMatchInfo.
   * @param {WplMatchInfoCreateArgs} args - Arguments to create a WplMatchInfo.
   * @example
   * // Create one WplMatchInfo
   * const WplMatchInfo = await prisma.wplMatchInfo.create({
   *   data: {
   *     // ... data to create a WplMatchInfo
   *   }
   * })
   *
   */
  create<T extends WplMatchInfoCreateArgs>(
    args: Prisma.SelectSubset<T, WplMatchInfoCreateArgs<ExtArgs>>,
  ): Prisma.Prisma__WplMatchInfoClient<
    runtime.Types.Result.GetResult<
      Prisma.$WplMatchInfoPayload<ExtArgs>,
      T,
      'create',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Create many WplMatchInfos.
   * @param {WplMatchInfoCreateManyArgs} args - Arguments to create many WplMatchInfos.
   * @example
   * // Create many WplMatchInfos
   * const wplMatchInfo = await prisma.wplMatchInfo.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   */
  createMany<T extends WplMatchInfoCreateManyArgs>(
    args?: Prisma.SelectSubset<T, WplMatchInfoCreateManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Create many WplMatchInfos and returns the data saved in the database.
   * @param {WplMatchInfoCreateManyAndReturnArgs} args - Arguments to create many WplMatchInfos.
   * @example
   * // Create many WplMatchInfos
   * const wplMatchInfo = await prisma.wplMatchInfo.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Create many WplMatchInfos and only return the `id`
   * const wplMatchInfoWithIdOnly = await prisma.wplMatchInfo.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  createManyAndReturn<T extends WplMatchInfoCreateManyAndReturnArgs>(
    args?: Prisma.SelectSubset<T, WplMatchInfoCreateManyAndReturnArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$WplMatchInfoPayload<ExtArgs>,
      T,
      'createManyAndReturn',
      GlobalOmitOptions
    >
  >;

  /**
   * Delete a WplMatchInfo.
   * @param {WplMatchInfoDeleteArgs} args - Arguments to delete one WplMatchInfo.
   * @example
   * // Delete one WplMatchInfo
   * const WplMatchInfo = await prisma.wplMatchInfo.delete({
   *   where: {
   *     // ... filter to delete one WplMatchInfo
   *   }
   * })
   *
   */
  delete<T extends WplMatchInfoDeleteArgs>(
    args: Prisma.SelectSubset<T, WplMatchInfoDeleteArgs<ExtArgs>>,
  ): Prisma.Prisma__WplMatchInfoClient<
    runtime.Types.Result.GetResult<
      Prisma.$WplMatchInfoPayload<ExtArgs>,
      T,
      'delete',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Update one WplMatchInfo.
   * @param {WplMatchInfoUpdateArgs} args - Arguments to update one WplMatchInfo.
   * @example
   * // Update one WplMatchInfo
   * const wplMatchInfo = await prisma.wplMatchInfo.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  update<T extends WplMatchInfoUpdateArgs>(
    args: Prisma.SelectSubset<T, WplMatchInfoUpdateArgs<ExtArgs>>,
  ): Prisma.Prisma__WplMatchInfoClient<
    runtime.Types.Result.GetResult<
      Prisma.$WplMatchInfoPayload<ExtArgs>,
      T,
      'update',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Delete zero or more WplMatchInfos.
   * @param {WplMatchInfoDeleteManyArgs} args - Arguments to filter WplMatchInfos to delete.
   * @example
   * // Delete a few WplMatchInfos
   * const { count } = await prisma.wplMatchInfo.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   *
   */
  deleteMany<T extends WplMatchInfoDeleteManyArgs>(
    args?: Prisma.SelectSubset<T, WplMatchInfoDeleteManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more WplMatchInfos.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WplMatchInfoUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many WplMatchInfos
   * const wplMatchInfo = await prisma.wplMatchInfo.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  updateMany<T extends WplMatchInfoUpdateManyArgs>(
    args: Prisma.SelectSubset<T, WplMatchInfoUpdateManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more WplMatchInfos and returns the data updated in the database.
   * @param {WplMatchInfoUpdateManyAndReturnArgs} args - Arguments to update many WplMatchInfos.
   * @example
   * // Update many WplMatchInfos
   * const wplMatchInfo = await prisma.wplMatchInfo.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Update zero or more WplMatchInfos and only return the `id`
   * const wplMatchInfoWithIdOnly = await prisma.wplMatchInfo.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  updateManyAndReturn<T extends WplMatchInfoUpdateManyAndReturnArgs>(
    args: Prisma.SelectSubset<T, WplMatchInfoUpdateManyAndReturnArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$WplMatchInfoPayload<ExtArgs>,
      T,
      'updateManyAndReturn',
      GlobalOmitOptions
    >
  >;

  /**
   * Create or update one WplMatchInfo.
   * @param {WplMatchInfoUpsertArgs} args - Arguments to update or create a WplMatchInfo.
   * @example
   * // Update or create a WplMatchInfo
   * const wplMatchInfo = await prisma.wplMatchInfo.upsert({
   *   create: {
   *     // ... data to create a WplMatchInfo
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the WplMatchInfo we want to update
   *   }
   * })
   */
  upsert<T extends WplMatchInfoUpsertArgs>(
    args: Prisma.SelectSubset<T, WplMatchInfoUpsertArgs<ExtArgs>>,
  ): Prisma.Prisma__WplMatchInfoClient<
    runtime.Types.Result.GetResult<
      Prisma.$WplMatchInfoPayload<ExtArgs>,
      T,
      'upsert',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Count the number of WplMatchInfos.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WplMatchInfoCountArgs} args - Arguments to filter WplMatchInfos to count.
   * @example
   * // Count the number of WplMatchInfos
   * const count = await prisma.wplMatchInfo.count({
   *   where: {
   *     // ... the filter for the WplMatchInfos we want to count
   *   }
   * })
   **/
  count<T extends WplMatchInfoCountArgs>(
    args?: Prisma.Subset<T, WplMatchInfoCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], WplMatchInfoCountAggregateOutputType>
      : number
  >;

  /**
   * Allows you to perform aggregations operations on a WplMatchInfo.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WplMatchInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
   **/
  aggregate<T extends WplMatchInfoAggregateArgs>(
    args: Prisma.Subset<T, WplMatchInfoAggregateArgs>,
  ): Prisma.PrismaPromise<GetWplMatchInfoAggregateType<T>>;

  /**
   * Group by WplMatchInfo.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WplMatchInfoGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   *
   **/
  groupBy<
    T extends WplMatchInfoGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: WplMatchInfoGroupByArgs['orderBy'] }
      : { orderBy?: WplMatchInfoGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<
      Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>
    >,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
      ? `Error: "by" must not be empty.`
      : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
                ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
          }[HavingFields]
        : 'take' extends Prisma.Keys<T>
          ? 'orderBy' extends Prisma.Keys<T>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields]
            : 'Error: If you provide "take", you also need to provide "orderBy"'
          : 'skip' extends Prisma.Keys<T>
            ? 'orderBy' extends Prisma.Keys<T>
              ? ByValid extends Prisma.True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "skip", you also need to provide "orderBy"'
            : ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields],
  >(
    args: Prisma.SubsetIntersection<T, WplMatchInfoGroupByArgs, OrderByArg> & InputErrors,
  ): {} extends InputErrors ? GetWplMatchInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
  /**
   * Fields of the WplMatchInfo model
   */
  readonly fields: WplMatchInfoFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for WplMatchInfo.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__WplMatchInfoClient<
  T,
  Null = never,
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: 'PrismaPromise';
  teams<T extends Prisma.WplMatchInfo$teamsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.WplMatchInfo$teamsArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$WplTeamPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    | Null
  >;
  players<T extends Prisma.WplMatchInfo$playersArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.WplMatchInfo$playersArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$WplPlayerPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    | Null
  >;
  officials<T extends Prisma.WplMatchInfo$officialsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.WplMatchInfo$officialsArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$WplOfficialPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    | Null
  >;
  peopleRegistry<T extends Prisma.WplMatchInfo$peopleRegistryArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.WplMatchInfo$peopleRegistryArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$WplPersonRegistryPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    | Null
  >;
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
  ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
  ): runtime.Types.Utils.JsPromise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the WplMatchInfo model
 */
export interface WplMatchInfoFieldRefs {
  readonly id: Prisma.FieldRef<'WplMatchInfo', 'Int'>;
  readonly league: Prisma.FieldRef<'WplMatchInfo', 'String'>;
  readonly version: Prisma.FieldRef<'WplMatchInfo', 'String'>;
  readonly ballsPerOver: Prisma.FieldRef<'WplMatchInfo', 'Int'>;
  readonly gender: Prisma.FieldRef<'WplMatchInfo', 'String'>;
  readonly season: Prisma.FieldRef<'WplMatchInfo', 'String'>;
  readonly date: Prisma.FieldRef<'WplMatchInfo', 'DateTime'>;
  readonly event: Prisma.FieldRef<'WplMatchInfo', 'String'>;
  readonly matchNumber: Prisma.FieldRef<'WplMatchInfo', 'Int'>;
  readonly venue: Prisma.FieldRef<'WplMatchInfo', 'String'>;
  readonly city: Prisma.FieldRef<'WplMatchInfo', 'String'>;
  readonly tossWinner: Prisma.FieldRef<'WplMatchInfo', 'String'>;
  readonly tossDecision: Prisma.FieldRef<'WplMatchInfo', 'String'>;
  readonly playerOfMatch: Prisma.FieldRef<'WplMatchInfo', 'String'>;
  readonly winner: Prisma.FieldRef<'WplMatchInfo', 'String'>;
  readonly winnerRuns: Prisma.FieldRef<'WplMatchInfo', 'Int'>;
  readonly winnerWickets: Prisma.FieldRef<'WplMatchInfo', 'Int'>;
}

// Custom InputTypes
/**
 * WplMatchInfo findUnique
 */
export type WplMatchInfoFindUniqueArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplMatchInfo
   */
  select?: Prisma.WplMatchInfoSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WplMatchInfo
   */
  omit?: Prisma.WplMatchInfoOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WplMatchInfoInclude<ExtArgs> | null;
  /**
   * Filter, which WplMatchInfo to fetch.
   */
  where: Prisma.WplMatchInfoWhereUniqueInput;
};

/**
 * WplMatchInfo findUniqueOrThrow
 */
export type WplMatchInfoFindUniqueOrThrowArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplMatchInfo
   */
  select?: Prisma.WplMatchInfoSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WplMatchInfo
   */
  omit?: Prisma.WplMatchInfoOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WplMatchInfoInclude<ExtArgs> | null;
  /**
   * Filter, which WplMatchInfo to fetch.
   */
  where: Prisma.WplMatchInfoWhereUniqueInput;
};

/**
 * WplMatchInfo findFirst
 */
export type WplMatchInfoFindFirstArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplMatchInfo
   */
  select?: Prisma.WplMatchInfoSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WplMatchInfo
   */
  omit?: Prisma.WplMatchInfoOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WplMatchInfoInclude<ExtArgs> | null;
  /**
   * Filter, which WplMatchInfo to fetch.
   */
  where?: Prisma.WplMatchInfoWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of WplMatchInfos to fetch.
   */
  orderBy?:
    | Prisma.WplMatchInfoOrderByWithRelationInput
    | Prisma.WplMatchInfoOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for WplMatchInfos.
   */
  cursor?: Prisma.WplMatchInfoWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` WplMatchInfos from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` WplMatchInfos.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of WplMatchInfos.
   */
  distinct?: Prisma.WplMatchInfoScalarFieldEnum | Prisma.WplMatchInfoScalarFieldEnum[];
};

/**
 * WplMatchInfo findFirstOrThrow
 */
export type WplMatchInfoFindFirstOrThrowArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplMatchInfo
   */
  select?: Prisma.WplMatchInfoSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WplMatchInfo
   */
  omit?: Prisma.WplMatchInfoOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WplMatchInfoInclude<ExtArgs> | null;
  /**
   * Filter, which WplMatchInfo to fetch.
   */
  where?: Prisma.WplMatchInfoWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of WplMatchInfos to fetch.
   */
  orderBy?:
    | Prisma.WplMatchInfoOrderByWithRelationInput
    | Prisma.WplMatchInfoOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for WplMatchInfos.
   */
  cursor?: Prisma.WplMatchInfoWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` WplMatchInfos from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` WplMatchInfos.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of WplMatchInfos.
   */
  distinct?: Prisma.WplMatchInfoScalarFieldEnum | Prisma.WplMatchInfoScalarFieldEnum[];
};

/**
 * WplMatchInfo findMany
 */
export type WplMatchInfoFindManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplMatchInfo
   */
  select?: Prisma.WplMatchInfoSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WplMatchInfo
   */
  omit?: Prisma.WplMatchInfoOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WplMatchInfoInclude<ExtArgs> | null;
  /**
   * Filter, which WplMatchInfos to fetch.
   */
  where?: Prisma.WplMatchInfoWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of WplMatchInfos to fetch.
   */
  orderBy?:
    | Prisma.WplMatchInfoOrderByWithRelationInput
    | Prisma.WplMatchInfoOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for listing WplMatchInfos.
   */
  cursor?: Prisma.WplMatchInfoWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` WplMatchInfos from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` WplMatchInfos.
   */
  skip?: number;
  distinct?: Prisma.WplMatchInfoScalarFieldEnum | Prisma.WplMatchInfoScalarFieldEnum[];
};

/**
 * WplMatchInfo create
 */
export type WplMatchInfoCreateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplMatchInfo
   */
  select?: Prisma.WplMatchInfoSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WplMatchInfo
   */
  omit?: Prisma.WplMatchInfoOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WplMatchInfoInclude<ExtArgs> | null;
  /**
   * The data needed to create a WplMatchInfo.
   */
  data: Prisma.XOR<Prisma.WplMatchInfoCreateInput, Prisma.WplMatchInfoUncheckedCreateInput>;
};

/**
 * WplMatchInfo createMany
 */
export type WplMatchInfoCreateManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to create many WplMatchInfos.
   */
  data: Prisma.WplMatchInfoCreateManyInput | Prisma.WplMatchInfoCreateManyInput[];
  skipDuplicates?: boolean;
};

/**
 * WplMatchInfo createManyAndReturn
 */
export type WplMatchInfoCreateManyAndReturnArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplMatchInfo
   */
  select?: Prisma.WplMatchInfoSelectCreateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the WplMatchInfo
   */
  omit?: Prisma.WplMatchInfoOmit<ExtArgs> | null;
  /**
   * The data used to create many WplMatchInfos.
   */
  data: Prisma.WplMatchInfoCreateManyInput | Prisma.WplMatchInfoCreateManyInput[];
  skipDuplicates?: boolean;
};

/**
 * WplMatchInfo update
 */
export type WplMatchInfoUpdateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplMatchInfo
   */
  select?: Prisma.WplMatchInfoSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WplMatchInfo
   */
  omit?: Prisma.WplMatchInfoOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WplMatchInfoInclude<ExtArgs> | null;
  /**
   * The data needed to update a WplMatchInfo.
   */
  data: Prisma.XOR<Prisma.WplMatchInfoUpdateInput, Prisma.WplMatchInfoUncheckedUpdateInput>;
  /**
   * Choose, which WplMatchInfo to update.
   */
  where: Prisma.WplMatchInfoWhereUniqueInput;
};

/**
 * WplMatchInfo updateMany
 */
export type WplMatchInfoUpdateManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to update WplMatchInfos.
   */
  data: Prisma.XOR<
    Prisma.WplMatchInfoUpdateManyMutationInput,
    Prisma.WplMatchInfoUncheckedUpdateManyInput
  >;
  /**
   * Filter which WplMatchInfos to update
   */
  where?: Prisma.WplMatchInfoWhereInput;
  /**
   * Limit how many WplMatchInfos to update.
   */
  limit?: number;
};

/**
 * WplMatchInfo updateManyAndReturn
 */
export type WplMatchInfoUpdateManyAndReturnArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplMatchInfo
   */
  select?: Prisma.WplMatchInfoSelectUpdateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the WplMatchInfo
   */
  omit?: Prisma.WplMatchInfoOmit<ExtArgs> | null;
  /**
   * The data used to update WplMatchInfos.
   */
  data: Prisma.XOR<
    Prisma.WplMatchInfoUpdateManyMutationInput,
    Prisma.WplMatchInfoUncheckedUpdateManyInput
  >;
  /**
   * Filter which WplMatchInfos to update
   */
  where?: Prisma.WplMatchInfoWhereInput;
  /**
   * Limit how many WplMatchInfos to update.
   */
  limit?: number;
};

/**
 * WplMatchInfo upsert
 */
export type WplMatchInfoUpsertArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplMatchInfo
   */
  select?: Prisma.WplMatchInfoSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WplMatchInfo
   */
  omit?: Prisma.WplMatchInfoOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WplMatchInfoInclude<ExtArgs> | null;
  /**
   * The filter to search for the WplMatchInfo to update in case it exists.
   */
  where: Prisma.WplMatchInfoWhereUniqueInput;
  /**
   * In case the WplMatchInfo found by the `where` argument doesn't exist, create a new WplMatchInfo with this data.
   */
  create: Prisma.XOR<Prisma.WplMatchInfoCreateInput, Prisma.WplMatchInfoUncheckedCreateInput>;
  /**
   * In case the WplMatchInfo was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.WplMatchInfoUpdateInput, Prisma.WplMatchInfoUncheckedUpdateInput>;
};

/**
 * WplMatchInfo delete
 */
export type WplMatchInfoDeleteArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplMatchInfo
   */
  select?: Prisma.WplMatchInfoSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WplMatchInfo
   */
  omit?: Prisma.WplMatchInfoOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WplMatchInfoInclude<ExtArgs> | null;
  /**
   * Filter which WplMatchInfo to delete.
   */
  where: Prisma.WplMatchInfoWhereUniqueInput;
};

/**
 * WplMatchInfo deleteMany
 */
export type WplMatchInfoDeleteManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which WplMatchInfos to delete
   */
  where?: Prisma.WplMatchInfoWhereInput;
  /**
   * Limit how many WplMatchInfos to delete.
   */
  limit?: number;
};

/**
 * WplMatchInfo.teams
 */
export type WplMatchInfo$teamsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplTeam
   */
  select?: Prisma.WplTeamSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WplTeam
   */
  omit?: Prisma.WplTeamOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WplTeamInclude<ExtArgs> | null;
  where?: Prisma.WplTeamWhereInput;
  orderBy?: Prisma.WplTeamOrderByWithRelationInput | Prisma.WplTeamOrderByWithRelationInput[];
  cursor?: Prisma.WplTeamWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.WplTeamScalarFieldEnum | Prisma.WplTeamScalarFieldEnum[];
};

/**
 * WplMatchInfo.players
 */
export type WplMatchInfo$playersArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplPlayer
   */
  select?: Prisma.WplPlayerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WplPlayer
   */
  omit?: Prisma.WplPlayerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WplPlayerInclude<ExtArgs> | null;
  where?: Prisma.WplPlayerWhereInput;
  orderBy?: Prisma.WplPlayerOrderByWithRelationInput | Prisma.WplPlayerOrderByWithRelationInput[];
  cursor?: Prisma.WplPlayerWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.WplPlayerScalarFieldEnum | Prisma.WplPlayerScalarFieldEnum[];
};

/**
 * WplMatchInfo.officials
 */
export type WplMatchInfo$officialsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplOfficial
   */
  select?: Prisma.WplOfficialSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WplOfficial
   */
  omit?: Prisma.WplOfficialOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WplOfficialInclude<ExtArgs> | null;
  where?: Prisma.WplOfficialWhereInput;
  orderBy?:
    | Prisma.WplOfficialOrderByWithRelationInput
    | Prisma.WplOfficialOrderByWithRelationInput[];
  cursor?: Prisma.WplOfficialWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.WplOfficialScalarFieldEnum | Prisma.WplOfficialScalarFieldEnum[];
};

/**
 * WplMatchInfo.peopleRegistry
 */
export type WplMatchInfo$peopleRegistryArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplPersonRegistry
   */
  select?: Prisma.WplPersonRegistrySelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WplPersonRegistry
   */
  omit?: Prisma.WplPersonRegistryOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WplPersonRegistryInclude<ExtArgs> | null;
  where?: Prisma.WplPersonRegistryWhereInput;
  orderBy?:
    | Prisma.WplPersonRegistryOrderByWithRelationInput
    | Prisma.WplPersonRegistryOrderByWithRelationInput[];
  cursor?: Prisma.WplPersonRegistryWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.WplPersonRegistryScalarFieldEnum | Prisma.WplPersonRegistryScalarFieldEnum[];
};

/**
 * WplMatchInfo without action
 */
export type WplMatchInfoDefaultArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the WplMatchInfo
   */
  select?: Prisma.WplMatchInfoSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WplMatchInfo
   */
  omit?: Prisma.WplMatchInfoOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WplMatchInfoInclude<ExtArgs> | null;
};
